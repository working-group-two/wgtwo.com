"use strict";(self.webpackChunkworking_group_two_website=self.webpackChunkworking_group_two_website||[]).push([[1267],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,N=u["".concat(s,".").concat(c)]||u[c]||m[c]||r;return n?a.createElement(N,l(l({ref:t},d),{},{components:n})):a.createElement(N,l({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},42787:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return m}});var a=n(87462),i=n(63366),r=(n(67294),n(3905)),l=["components"],o={slug:"the-specs-behind-the-specs-part-1",title:"The specs behind the specs part 1",date:new Date("2022-01-11T00:00:00.000Z"),tags:["telco","ASN.1","dia"],authors:"seba"},s=void 0,p={permalink:"/blog/the-specs-behind-the-specs-part-1",editUrl:"https://github.com/working-group-two/wgtwo.com/edit/main/blog/../blog/2022-01-11-the-spec-behind-the-specs.md",source:"@site/../blog/2022-01-11-the-spec-behind-the-specs.md",title:"The specs behind the specs part 1",description:'"Abstract Syntax Notation One (ASN.1) is a standard interface',date:"2022-01-11T00:00:00.000Z",formattedDate:"January 11, 2022",tags:[{label:"telco",permalink:"/blog/tags/telco"},{label:"ASN.1",permalink:"/blog/tags/asn-1"},{label:"dia",permalink:"/blog/tags/dia"}],readingTime:31.125,hasTruncateMarker:!0,authors:[{name:"Sebastian Weddmark Olsson",title:"Tech Lead for Session Management & Protocol Termination",url:"https://www.linkedin.com/in/sebastian-weddmark-olsson/",imageURL:"/img/author-photos/swo.jpg",key:"seba"}],frontMatter:{slug:"the-specs-behind-the-specs-part-1",title:"The specs behind the specs part 1",date:"2022-01-11T00:00:00.000Z",tags:["telco","ASN.1","dia"],authors:"seba"},prevItem:{title:"Don't leave a message after the beep",permalink:"/blog/please-dont-leave-a-message-after-the-beep"},nextItem:{title:"Zero-day vulnerabilities - Log4j",permalink:"/blog/log4j-security-vulnerability"}},d={authorsImageUrls:[void 0]},m=[{value:"The how and why",id:"the-how-and-why",level:2},{value:"Modules",id:"modules",level:2},{value:"Importing from other modules",id:"importing-from-other-modules",level:3},{value:"Exporting from a module",id:"exporting-from-a-module",level:3},{value:"Commenting",id:"commenting",level:3},{value:"Assignments and naming",id:"assignments-and-naming",level:2},{value:"Basic types",id:"basic-types",level:2},{value:"BOOLEAN",id:"boolean",level:3},{value:"NULL",id:"null",level:3},{value:"INTEGER",id:"integer",level:3},{value:"ENUMERATED",id:"enumerated",level:3},{value:"BIT STRING",id:"bit-string",level:3},{value:"OCTET STRING",id:"octet-string",level:3},{value:"OBJECT IDENTIFIER",id:"object-identifier",level:3},{value:"EXTERNAL",id:"external",level:3},{value:"REAL",id:"real",level:3},{value:"String types",id:"string-types",level:3},{value:"Time types",id:"time-types",level:3},{value:"Structured types",id:"structured-types",level:2},{value:"CHOICE",id:"choice",level:3},{value:"SEQUENCE (OF)",id:"sequence-of",level:3},{value:"SET (OF)",id:"set-of",level:3},{value:"SELECTION",id:"selection",level:3},{value:"DEFAULT and OPTIONAL keywords",id:"default-and-optional-keywords",level:2},{value:"Classes",id:"classes",level:2},{value:"Parameterized components",id:"parameterized-components",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Automatic, Implicit, Explicit tags",id:"automatic-implicit-explicit-tags",level:2},{value:"Deprecations and discouragements",id:"deprecations-and-discouragements",level:2},{value:"ANY",id:"any",level:3},{value:"Macros",id:"macros",level:3}],u={toc:m};function c(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'"Abstract Syntax Notation One (ASN.1) is a standard interface\ndescription language for defining data structures that can be\nserialized and deserialized in a cross-platform way." -\n',(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/ASN.1"},"Wikipedia")),(0,r.kt)("h1",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Today you'll read about a specific language used to describe many of\nthe messages in the telecom specifications. It will be a deep-dive\ninto technical parts, so I imagine you could just use the blog post\nwhen you want to look up different parts without fully reading it."),(0,r.kt)("p",null,"In ",(0,r.kt)("strong",{parentName:"p"},"wgtwo")," we use this language for some specific telco\nmessages (such as SIGTRAN layers TCAP/MAP/CAP, as well as S1AP, NGAP\nand probably some more). They are defined directly in some of the\ntelecom specifications, and because of that it is possible to use them\nto send messages between different telecom cores."),(0,r.kt)("p",null,"This will ",(0,r.kt)("em",{parentName:"p"},"probably")," be a two piece blog post as there is another\ninterface describing language which is not ASN.1, and this is already\na very long post. The other specification is used in Diameter\ndictionaries, but I'll spare those for now. It has already taken me\nabout half a year to finish up this article."),(0,r.kt)("p",null,"There might be some Erlang specific paragraphs here and there, but\nthis blog post is mainly about ASN.1 as a specification, which can be\nused in any language supporting it.  For Erlang specifics I came\nacross ",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/erlang-battleground/erlang-asn-1-abstract-syntax-notation-one-deeb8300f479"},"this blog\npost"),"\nwritten by Viacheslav Katsuba, and because it is build into Erlang by\ndefault I recommend the\n",(0,r.kt)("a",{parentName:"p",href:"https://www.erlang.org/doc/apps/asn1/asn1_getting_started.html"},"APIs"),"\nas well."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DISCLAIMER: SEVERE HEADACHE MIGHT FOLLOW.")),(0,r.kt)("h1",{id:"abstract-syntax-notation-one"},"Abstract Syntax Notation One"),(0,r.kt)("p",null,"Abstract Syntax Notation One (ASN.1 for short) provides a\nhigh level description of messages. It abstracts the language\nimplementations from the protocol design."),(0,r.kt)("p",null,"It was initially used by ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Open_Systems_Interconnection"},"Open Systems Interconnection\n(OSI)")," to\ndescribe email messages but is used by many other applications\nespecially within telecommunications and cryptography."),(0,r.kt)("p",null,"You might have heard of similar such abstract syntax notations used\nfor interface definitions such as Google Protocol Buffers, or\nFacebook's Apache Thrift, but those languages have not been managed by\na standardization organization, so the owning corporations could (in\ntheory) make breaking changes or change the license or even remove the\nlanguage definitions overnight."),(0,r.kt)("p",null,"Anyway, back to ASN.1"),(0,r.kt)("p",null,"The first ASN.1 standardization came out 1984, and there have been\nmany improvements since, for instance with the 1994 update which added\nextended functionality for telecommunication technologies."),(0,r.kt)("p",null,'"Long live ASN.1!" - Olivier Dubuisson from the ',(0,r.kt)("a",{parentName:"p",href:"https://www.oss.com/asn1/resources/books-whitepapers-pubs/asn1-books.html#dubuisson"},"best\nbook"),"\nthat I've read on the subject. (How many ASN.1 books are there you\nmight wonder? Actually there were ",(0,r.kt)("a",{parentName:"p",href:"https://www.oss.com/asn1/resources/books-whitepapers-pubs/asn1-books.html"},"more\nbooks"),"\nthan I expected on the subject, but to make it perfectly clear: I did\nonly read the one.)"),(0,r.kt)("p",null,"Off-topic but a bit of a fun fact I got from reading the book which I\ndidn't know about before is that 'little Endian' and 'big Endian',\nwhich are used to denote if the bitstring should be read from leftmost\nor rightmost bit, actually originates from the 1726 best-seller\n",(0,r.kt)("a",{parentName:"p",href:"https://www.ling.upenn.edu/courses/Spring_2003/ling538/Lecnotes/ADfn1.htm"},"Gulliver's\ntravels"),"."),(0,r.kt)("h2",{id:"the-how-and-why"},"The how and why"),(0,r.kt)("p",null,"ASN.1 builds on the following ideas:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Data structures to be transmitted should be described regardless of\nprogramming language used transmitting or receiving them."),(0,r.kt)("li",{parentName:"ul"},"The notation should allow building complex data types from basic\ntypes, and be able to do so recursively."),(0,r.kt)("li",{parentName:"ul"},"The notation must be formal to prevent ambiguities.")),(0,r.kt)("p",null,"That said, ASN.1 is not an abstract syntax in itself, but a language\nto describe abstract syntaxes."),(0,r.kt)("p",null,"There are currently four main ASN.1 specifications (listed below), as\nwell as at least one specification per encoding rule (listed in the\n",(0,r.kt)("a",{parentName:"p",href:"#encodings"},"last section"),")."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"ITU-T no"),(0,r.kt)("th",{parentName:"tr",align:null},"ASN.1 specifications"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.680"},"X.680")),(0,r.kt)("td",{parentName:"tr",align:null},"Abstract Syntax Notation One (ASN.1): Specification of basic notation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.681"},"X.681")),(0,r.kt)("td",{parentName:"tr",align:null},"Abstract Syntax Notation One (ASN.1): Information object specification")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.682"},"X.682")),(0,r.kt)("td",{parentName:"tr",align:null},"Abstract Syntax Notation One (ASN.1): Constraint specification")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.683"},"X.683")),(0,r.kt)("td",{parentName:"tr",align:null},"Abstract Syntax Notation One (ASN.1): Parameterization of ASN.1 specifications")))),(0,r.kt)("h1",{id:"nitty-gritty"},"Nitty gritty"),(0,r.kt)("h2",{id:"modules"},"Modules"),(0,r.kt)("p",null,"The purpose of an ASN.1 module is to name a collection of types and/or\nvalue definitions."),(0,r.kt)("p",null,"It consist of a module reference and an optional object identifier\ntogether with the declaration of the ",(0,r.kt)("inlineCode",{parentName:"p"},"DEFINITIONS")," type definition.\nNote that even though the object identifier is optional, it is\nconsidered bad practice to leave it out. The reason for it being\noptional is for backward compatibility; it was not part of the\noriginal ASN.1 specification.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"DEFINITIONS")," keyword usually comes together with the ",(0,r.kt)("inlineCode",{parentName:"p"},"BEGIN")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"END")," keywords so multiple definitions can be done. (What else is the\npoint of a module if not to make a collection...)."),(0,r.kt)("p",null,"The Erlang ASN.1 compiler requires each module to be in a separate\nfile, but generally one ASN.1 file could contain many modules.  Usual\nfile endings are ",(0,r.kt)("inlineCode",{parentName:"p"},".asn")," and ",(0,r.kt)("inlineCode",{parentName:"p"},".asn1"),". One\n",(0,r.kt)("a",{parentName:"p",href:"https://www.erlang.org/doc/apps/asn1/asn1_getting_started.html#multi-file-compilation"},"trick"),"\nthat can be used to circumvent this Erlang specific problem is to list\nmultiple ASN.1 files in a new file ending with ",(0,r.kt)("inlineCode",{parentName:"p"},"set.asn"),"."),(0,r.kt)("p",null,"The ASN.1 template for a module"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"ModuleReference ObjectIdentifier\nDEFINITIONS ::= BEGIN\n\nEND\n")),(0,r.kt)("p",null,"as seen in an example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"CAP-operationcodes {itu-t(0) identified-organization(4) etsi(0) mobileDomain(0) umts-network(1)\nmodules(3) cap-operationcodes(53) version8(7)}\n\nDEFINITIONS ::= BEGIN\n")),(0,r.kt)("p",null,"For information about the object identifier see the ",(0,r.kt)("a",{parentName:"p",href:"#object-identifier"},"types section")),(0,r.kt)("h3",{id:"importing-from-other-modules"},"Importing from other modules"),(0,r.kt)("p",null,"Importing types, values and other structures from other modules can be\ndone with the ",(0,r.kt)("inlineCode",{parentName:"p"},"IMPORTS")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM")," keywords in the beginning of the\nmodule body.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"IMPORTS")," keyword ends with a single semicolon ",(0,r.kt)("inlineCode",{parentName:"p"},";"),",\nand the different imported definitions are comma-separated."),(0,r.kt)("p",null,"The meaning of the optional ",(0,r.kt)("inlineCode",{parentName:"p"},"IMPLICIT TAGS")," keywords I'll handle\n",(0,r.kt)("a",{parentName:"p",href:"#automatic-implicit-explicit-tags"},"later"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"CAP-datatypes {itu-t(0) identified-organization(4) etsi(0) mobileDomain(0) umts-network(1) modules(3) cap-datatypes(52) version8(7)}\nDEFINITIONS IMPLICIT TAGS ::= BEGIN\n\nIMPORTS\n\n    Duration,\n    Integer4,\n    Interval,\n    LegID,\n    ServiceKey\nFROM CS1-DataTypes {itu-t(0) identified-organization(4) etsi(0) inDomain(1) in-network(1)\nmodules(0) cs1-datatypes(2) version1(0)}\n\n    BothwayThroughConnectionInd,\n    CriticalityType,\n    MiscCallInfo\nFROM CS2-datatypes {itu-t(0) identified-organization(4) etsi(0) inDomain(1) in-network(1)\ncs2(20) modules(0) in-cs2-datatypes(0) version1(0)}\n\n-- ...more imports...\n; -- IMPORTS end here\n\nEND -- CAP-datatypes ends here --\n\n-- CAP-errortypes module starts here --\nCAP-errortypes {itu-t(0) identified-organization(4) etsi(0) mobileDomain(0) umts-network(1) modules(3) cap-errortypes(51) version8(7)}\nDEFINITIONS IMPLICIT TAGS ::= BEGIN\n\n\nEND -- CAP-errortypes ends here --\n")),(0,r.kt)("p",null,"The type definitions ",(0,r.kt)("inlineCode",{parentName:"p"},"Duration")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"LegID")," above are imported from\n",(0,r.kt)("inlineCode",{parentName:"p"},"CS1-DataTypes")," module, while ",(0,r.kt)("inlineCode",{parentName:"p"},"MiscCallInfo")," comes from\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"CS2-datatypes")," module."),(0,r.kt)("h3",{id:"exporting-from-a-module"},"Exporting from a module"),(0,r.kt)("p",null,"Exports from a module are done in a similar fashion."),(0,r.kt)("p",null,"If the ",(0,r.kt)("inlineCode",{parentName:"p"},"EXPORT")," keyword is not used in a module, the ASN.1 compilers\nshould export all values and types from the module. It's the same as\nspecifying ",(0,r.kt)("inlineCode",{parentName:"p"},"EXPORTS ALL;"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"CAP-GPRS-ReferenceNumber {itu-t(0) identified-organization(4) etsi(0) mobileDomain(0)\numts-network(1) modules(3) cap-dialogueInformation(111) version8(7)}\n\nDEFINITIONS ::= BEGIN\n\nEXPORTS\n    id-CAP-GPRS-ReferenceNumber,\n    cAP-GPRS-ReferenceNumber-Abstract-Syntax;\n\nIMPORTS\n\n    Integer4\nFROM CS1-DataTypes {itu-t(0) identified-organization(4) etsi(0) inDomain(1) in-network(1)\nmodules(0) cs1-datatypes(2) version1(0)}\n;\n\nEND\n")),(0,r.kt)("h3",{id:"commenting"},"Commenting"),(0,r.kt)("p",null,"As can be seen in the above example one can enter comments into the\nASN.1.  Comments starts with double dash ",(0,r.kt)("inlineCode",{parentName:"p"},"--")," and ends with either a\nnewline or another ",(0,r.kt)("inlineCode",{parentName:"p"},"--"),", whichever comes first."),(0,r.kt)("h2",{id:"assignments-and-naming"},"Assignments and naming"),(0,r.kt)("p",null,"The rules specify that type references must start with an uppercase\nletter and may not end with a dash ",(0,r.kt)("inlineCode",{parentName:"p"},"-"),". It may also only contain\nupper- and lower-case letters, digits or dashes ",(0,r.kt)("inlineCode",{parentName:"p"},"-"),".  The syntax for a\ntype assignment is"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"TypeRef ::= TypeDefinition\n")),(0,r.kt)("p",null,"For instance"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"InvokeIdType ::= INTEGER (-128..127)\n\nCancelArg ::= CHOICE {\n    invokeID        [0] InvokeID,\n    allRequests     [1] NULL\n}\n\nDuration ::= INTEGER (-2..86400)\n\nInteger4 ::= INTEGER (0..2147483647)\n\nInterval ::= INTEGER (-1..60000)\n\nInvokeID ::= InvokeIdType\n\nLegID ::= CHOICE {\n    sendingSideID   [0] LegType,\n    -- used in operations sent from SCF to SSF\n    receivingSideID [1] LegType\n    -- used in operations sent from SSF to SCF\n}\n\nLegType ::= OCTET STRING (SIZE(1))\n\nServiceKey ::= Integer4\n")),(0,r.kt)("p",null,"Value references have a similar syntax as type references except that\nvalue references must start with a lower-case letter, and also carry\nthe values type."),(0,r.kt)("p",null,"Syntax"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"valueRef Type ::= value\n")),(0,r.kt)("p",null,"For example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"leg1 LegType ::= '01'H\nleg2 LegType ::= '02'H\n\nhighLayerCompatibilityLength            INTEGER ::= 2\nminAChBillingChargingLength             INTEGER ::= 0\n")),(0,r.kt)("h1",{id:"types"},"Types"),(0,r.kt)("p",null,"Now when we have talked a bit about naming references, and how to\nassign values and types I'll go over which built-in types exist, and\nhow to create new types."),(0,r.kt)("p",null,"There are some common types, each consists of a type reference and a\ntag number.  The tag number is used to identify it when sending the\ntype in the network.  The universal tags are specified in ",(0,r.kt)("a",{parentName:"p",href:"https://www.itu.int/rec/T-REC-X.680/en"},"ITU-T\nX.680")),(0,r.kt)("p",null,"Here is a list of the most common types"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Universal Tag Number"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#boolean"},"BOOLEAN")),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#integer"},"INTEGER")),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#bit-string"},"BIT STRING")),(0,r.kt)("td",{parentName:"tr",align:null},"3")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#octet-string"},"OCTET STRING")),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#null"},"NULL")),(0,r.kt)("td",{parentName:"tr",align:null},"5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#object-identifier"},"OBJECT IDENTIFIER")),(0,r.kt)("td",{parentName:"tr",align:null},"6")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#external"},"EXTERNAL")),(0,r.kt)("td",{parentName:"tr",align:null},"8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#real"},"REAL")),(0,r.kt)("td",{parentName:"tr",align:null},"9")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#enumerated"},"ENUMERATED")),(0,r.kt)("td",{parentName:"tr",align:null},"10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#string-types"},"UTF8String")),(0,r.kt)("td",{parentName:"tr",align:null},"12")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#time-types"},"TIME")),(0,r.kt)("td",{parentName:"tr",align:null},"14")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#sequence-of"},"SEQUENCE (OF)")),(0,r.kt)("td",{parentName:"tr",align:null},"16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#set-of"},"SET (OF)")),(0,r.kt)("td",{parentName:"tr",align:null},"17")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#string-types"},"NumericString")),(0,r.kt)("td",{parentName:"tr",align:null},"18")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#string-types"},"IA5String")),(0,r.kt)("td",{parentName:"tr",align:null},"22")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#time-types"},"UTCTime")),(0,r.kt)("td",{parentName:"tr",align:null},"23")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#time-types"},"GeneralizedTime")),(0,r.kt)("td",{parentName:"tr",align:null},"24")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#string-types"},"VisibleString")),(0,r.kt)("td",{parentName:"tr",align:null},"26")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#time-types"},"DATE")),(0,r.kt)("td",{parentName:"tr",align:null},"31")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#time-types"},"TIME-OF-DAY")),(0,r.kt)("td",{parentName:"tr",align:null},"32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#time-types"},"DATE-TIME")),(0,r.kt)("td",{parentName:"tr",align:null},"33")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#time-types"},"DURATION")),(0,r.kt)("td",{parentName:"tr",align:null},"34")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#choice"},"CHOICE")),(0,r.kt)("td",{parentName:"tr",align:null},"*")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#selection"},"SELECTION")),(0,r.kt)("td",{parentName:"tr",align:null},"*")))),(0,r.kt)("p",null,"The common types can be divided into simple and structured types.\nStructured types are the composition of multiple types (so called\ncomponent types) using one of the following types and keywords\n",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE OF"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SET"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SET OF"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"CHOICE"),", and/or\n",(0,r.kt)("inlineCode",{parentName:"p"},"SELECTION"),".  Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"CHOICE")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECTION")," does not ","[need to]","\nhave their own universal tags, due to those are consisting of other\ntypes."),(0,r.kt)("h2",{id:"basic-types"},"Basic types"),(0,r.kt)("h3",{id:"boolean"},"BOOLEAN"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"BOOLEAN")," type takes values ",(0,r.kt)("inlineCode",{parentName:"p"},"TRUE")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"FALSE"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"AudibleIndicator ::= CHOICE {\n    tone       BOOLEAN,\n    burstList  [1] BurstList\n}\n\n")),(0,r.kt)("p",null,"Here the value ",(0,r.kt)("inlineCode",{parentName:"p"},"tone")," of the composit type ",(0,r.kt)("inlineCode",{parentName:"p"},"AudibleIndicator")," is of\ntype ",(0,r.kt)("inlineCode",{parentName:"p"},"BOOLEAN"),". Note: It was one of the cleanest example I could find\nof a ",(0,r.kt)("inlineCode",{parentName:"p"},"BOOLEAN"),' in the ASN.1 files we use, because Telco often use a\nspecial "trick" when it comes to booleans in order to save bandwidth,\ni.e. the ',(0,r.kt)("inlineCode",{parentName:"p"},"NULL")," type."),(0,r.kt)("h3",{id:"null"},"NULL"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"NULL")," type is basically a placeholder, where the recognition of a\nvalue is important but the actual value is not."),(0,r.kt)("p",null,"In 3GPP it is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"BOOLEAN")," in the sense that a defined ",(0,r.kt)("inlineCode",{parentName:"p"},"NULL"),"\nvalue is considered ",(0,r.kt)("inlineCode",{parentName:"p"},"TRUE")," and if the value is missing it is\nconsidered ",(0,r.kt)("inlineCode",{parentName:"p"},"FALSE"),". The reason for this is that when sent over the\nnetwork with ",(0,r.kt)("a",{parentName:"p",href:"#encodings"},"BER encoding"),", it will take no space because\n",(0,r.kt)("inlineCode",{parentName:"p"},"BOOLEAN")," is always of length 1 but ",(0,r.kt)("inlineCode",{parentName:"p"},"NULL")," is always length 0,\ni.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"NULL")," does not contain a value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"CancelArg {PARAMETERS-BOUND : bound} ::= CHOICE {\n    invokeID            [0] InvokeID,\n    allRequests         [1] NULL,\n    callSegmentToCancel [2] CallSegmentToCancel {bound}\n}\n")),(0,r.kt)("p",null,"in this example ",(0,r.kt)("inlineCode",{parentName:"p"},"allRequests")," can be defined (then only the tag is\ntransmitted) or not at all."),(0,r.kt)("h3",{id:"integer"},"INTEGER"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"INTEGER")," takes any of the infinite set of integer values. It can also\nhave the additional notation that names some of the values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"GSMMAPOperationLocalvalue ::= INTEGER{\n    updateLocation (2),\n    cancelLocation (3),\n    provideRoamingNumber (4),\n    noteSubscriberDataModified (5),\n    resumeCallHandling (6),\n    insertSubscriberData (7),\n    -- rest of the named integers --\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"localvalue1 GSMMAPOperationLocalvalue ::= updateLocation\nlocalvalue2 GSMMAPOperationLocalvalue ::= 2\nlocalvalue3 GSMMAPOperationLocalvalue ::= -55413459\n")),(0,r.kt)("p",null,"are all valid ",(0,r.kt)("inlineCode",{parentName:"p"},"GSMMAPOperationLocalvalue"),"s."),(0,r.kt)("h3",{id:"enumerated"},"ENUMERATED"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ENUMERATED")," has the same interpretation as ",(0,r.kt)("inlineCode",{parentName:"p"},"INTEGER")," but will hold\nspecific values only."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"RequestedInformationType ::= ENUMERATED {\n    callAttemptElapsedTime(0),\n    callStopTime(1),\n    callConnectedElapsedTime(2),\n    calledAddress(3),\n    releaseCause(30)\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"reqInfoType1 RequestedInformationType ::= callAttemptElapsedTime\nreqInfoType2 RequestedInformationType ::= 0\n")),(0,r.kt)("p",null,"are both valid values of ",(0,r.kt)("inlineCode",{parentName:"p"},"RequestInformationType"),", while this is not:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"notValidReqInfoType RequestedInformationType ::= 4\n")),(0,r.kt)("h3",{id:"bit-string"},"BIT STRING"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"BIT STRING")," takes values that are a sequence of zero or more bits. It\ncan also take an additional notation that name certain bits in the bit\nsequence."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"DeferredLocationEventType ::= BIT STRING {\n    msAvailable (0) ,\n    enteringIntoArea (1),\n    leavingFromArea (2),\n    beingInsideArea (3) ,\n    periodicLDR (4)\n} (SIZE (1..16))\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"eventType1 DeferredLocationEventType ::= (msAvailable, beingInsideArea)\neventType2 DeferredLocationEventType ::= '10010'B\neventType3 DeferredLocationEventType ::= '12'H\n")),(0,r.kt)("p",null,"are all valid value definitions of the same bit sequence where the\nfirst and third bits are set, and no other bits are set.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," stands\nfor binary representation and ",(0,r.kt)("inlineCode",{parentName:"p"},"H")," for hexadecimal representation."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"SIZE")," is a constraint on the type defining it to be of a specific\nlength. This keyword comes as an extra notation for many of the\n",(0,r.kt)("inlineCode",{parentName:"p"},"STRING")," types below (as well as some of the other types)."),(0,r.kt)("h3",{id:"octet-string"},"OCTET STRING"),(0,r.kt)("p",null,"Type ",(0,r.kt)("inlineCode",{parentName:"p"},"OCTET STRING")," takes values that are an ordered sequence of zero\nor more (eight-bit) octets."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"MM-Code ::= OCTET STRING (SIZE (1))\n")),(0,r.kt)("p",null,"In the same manner as ",(0,r.kt)("inlineCode",{parentName:"p"},"BIT STRING")," both values below are valid\ninstances of ",(0,r.kt)("inlineCode",{parentName:"p"},"MM-Code"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"iMSI-Attach1 MM-Code ::= '00000010'B\niMSI-Attach2 MM-Code ::= '02'H\n")),(0,r.kt)("p",null,"while"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"notValidIMSI-Attach MM-Code ::= '10010'B\n")),(0,r.kt)("p",null,"is not considered a valid value due to it not being a multiple of eight bits."),(0,r.kt)("h3",{id:"object-identifier"},"OBJECT IDENTIFIER"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"OBJECT IDENTIFIER")," type (shortened ",(0,r.kt)("inlineCode",{parentName:"p"},"OID"),") names information\nobjects such as ASN.1 modules. The named information object is a node\non an object identifier tree that is managed at the international\nlevel."),(0,r.kt)("p",null,"ETSI for instance is managed by ITU-T\n",(0,r.kt)("inlineCode",{parentName:"p"},"itu-t(0) identified-organization(4) etsi(0)")),(0,r.kt)("div",null,(0,r.kt)("img",{src:"/img/blog/the-specs-behind-the-specs/etsi_asn1oidtree.gif",alt:"ETSI OID tree"})),(0,r.kt)("p",null,"and as can see in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Modules")," example version 8 of cap-datatypes is part of ETSI.\n",(0,r.kt)("inlineCode",{parentName:"p"},"CAP-datatypes {itu-t(0) identified-organization(4) etsi(0) mobileDomain(0) umts-network(1) modules(3) cap-datatypes(52) version8(7)}")),(0,r.kt)("p",null,"Other root arcs"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Root"),(0,r.kt)("th",{parentName:"tr",align:null},"Organization"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"ITU-T")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"ISO")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"joint-iso-itu-t")))),(0,r.kt)("p",null,"The labels are optional and the reference could also be written as ",(0,r.kt)("inlineCode",{parentName:"p"},"{0\n4 0 0 1 3 52 7}"),". Only positive integers are allowed including zero (0)."),(0,r.kt)("p",null,"Another example comes from the CAP-object-identifiers module in ETSI 129.078."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"tc-Messages OBJECT IDENTIFIER ::=\n    {itu-t recommendation q 773 modules(2) messages(1) version3(3)}\n\nid-CAP OBJECT IDENTIFIER ::=\n    {itu-t(0) identified-organization(4) etsi(0) mobileDomain(0)\n     umts-network(1) cap4(22)}\n\nid-ac OBJECT IDENTIFIER ::= {id-CAP ac(3)}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"id-ac")," is a child of the ",(0,r.kt)("inlineCode",{parentName:"p"},"id-CAP")," object identifier."),(0,r.kt)("p",null,"One could lookup object identifiers by visiting this amazing\n",(0,r.kt)("a",{parentName:"p",href:"https://oidref.com/"},"page (oidref.com)"),"."),(0,r.kt)("h3",{id:"external"},"EXTERNAL"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"EXTERNAL")," represents a value that does not need to be specified as a\nASN.1 type. It carries information on how the data should be interpreted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"Unidirectional {OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {\n  dialoguePortion  DialoguePortion OPTIONAL,\n  components       ComponentPortion{{Invokable}, {Returnable}}\n}\n\nDialoguePortion ::= [APPLICATION 11] EXPLICIT EXTERNAL\n")),(0,r.kt)("p",null,"Here the value ",(0,r.kt)("inlineCode",{parentName:"p"},"dialoguePortion")," will have tag 11 if specified, it is\nthen up to the application to decide how to deal with the value."),(0,r.kt)("h3",{id:"real"},"REAL"),(0,r.kt)("p",null,"Values of the type ",(0,r.kt)("inlineCode",{parentName:"p"},"REAL")," will take a triplet of numbers (m, b, e),\nwhere m is the mantissa (a signed number), b the base (2 or 10), and e\nthe exponent (a signed number)."),(0,r.kt)("p",null,"There are also three special values it can take ",(0,r.kt)("inlineCode",{parentName:"p"},"PLUS-INFINITY"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),",\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"MINUS-INFINITY"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"theBestRealValue REAL ::= (123, 10, -2) -- 1.23\nmaxValue REAL ::= PLUS-INFINITY\n")),(0,r.kt)("h3",{id:"string-types"},"String types"),(0,r.kt)("p",null,"I feel like most of the string types are the same, except that they\nall take diffrent character sets. I've already described ",(0,r.kt)("inlineCode",{parentName:"p"},"BIT STRING"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"OCTET STRING")," which both operate the bit set, but there is a\nlot of others that operate over character sets."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Tag"),(0,r.kt)("th",{parentName:"tr",align:null},"Character set regex/comment"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UTF8String"),(0,r.kt)("td",{parentName:"tr",align:null},"12"),(0,r.kt)("td",{parentName:"tr",align:null},"Synonymous with UniversalString at abstract level")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NumericString"),(0,r.kt)("td",{parentName:"tr",align:null},"18"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[0-9 ]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PrintableString"),(0,r.kt)("td",{parentName:"tr",align:null},"19"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[A-Za-z0-9'()+,./:=? -]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TelexString (T61String)"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"[ISO-IR]"," reg. #6, #87, #102, #103, #106, #107, #126, #144, #150, #153, #156, #164, #165, #168 + space,delete")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"VideotexString"),(0,r.kt)("td",{parentName:"tr",align:null},"21"),(0,r.kt)("td",{parentName:"tr",align:null},"[ISO-IR]"," reg. #1, #13, #72, #73, #87, #89, #102, #108, #126, #128, #129, #144, #150, #153, #164, #165, #168 + space,delete")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"IA5String"),(0,r.kt)("td",{parentName:"tr",align:null},"22"),(0,r.kt)("td",{parentName:"tr",align:null},"[ISO-IR]"," reg. #1, #6 + space,delete")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GraphicString"),(0,r.kt)("td",{parentName:"tr",align:null},"25"),(0,r.kt)("td",{parentName:"tr",align:null},"[ISO-IR]"," graphical sets (called 'G') + space")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"VisibleString (ISO646String)"),(0,r.kt)("td",{parentName:"tr",align:null},"26"),(0,r.kt)("td",{parentName:"tr",align:null},"[ISO-IR]"," reg. #6 + space")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GeneralString"),(0,r.kt)("td",{parentName:"tr",align:null},"27"),(0,r.kt)("td",{parentName:"tr",align:null},"[ISO-IR]"," graphical sets (called 'G'), control characters (called 'C') + space,delete")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UniversalString"),(0,r.kt)("td",{parentName:"tr",align:null},"28"),(0,r.kt)("td",{parentName:"tr",align:null},"[ISO10646-1]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BMPString"),(0,r.kt)("td",{parentName:"tr",align:null},"30"),(0,r.kt)("td",{parentName:"tr",align:null},"Basic Multilingual Plane; subtype of UniversalString")))),(0,r.kt)("p",null,"[ISO-IR]"," (ISO International Register of Coded Character Sets To Be\nUsed With Escape Sequences) is a pretty good source, it reference most\nof the registers but not all of them. The\ncharacter-sets are registered with\n",(0,r.kt)("a",{parentName:"p",href:"https://www.iana.org/assignments/character-sets/character-sets.xhtml"},"IANA")),(0,r.kt)("p",null,"I'll list some examples of string types found in our ASN.1 files:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"AMFNameUTF8String ::= UTF8String (SIZE(1..150, ...))\n\nDirectoryString ::= CHOICE {\n    teletexString TeletexString (SIZE (1..maxSize)),\n    printableString PrintableString (SIZE (1..maxSize)),\n    universalString UniversalString (SIZE (1..maxSize)),\n    bmpString BMPString (SIZE (1..maxSize))\n--    utf8String UTF8String (SIZE (1..maxSize))\n    }\n\nDisplayInformation ::= IA5String (SIZE (minDisplayInformationLength..maxDisplayInformationLength))\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"IA5String")," is used to represent ISO 646 (IA5; International Alphabet 5)\ncharacters.  The entire character set contains precisely 128\ncharacters and are generally equivalent to the first 128 characters of\nthe ASCII alphabet."),(0,r.kt)("p",null,"There are multiple formats for the values of ",(0,r.kt)("inlineCode",{parentName:"p"},"UniversalString"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"BMPString")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"UTF8String")," types. One could either specify a quadruple with ",(0,r.kt)("inlineCode",{parentName:"p"},"{group,\nplane, row, cell}")," for the character needed, or an array of defined values (strings)."),(0,r.kt)("p",null,"An example from Dubuisson:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},'latinCapitalLetterA UniversalString ::= {0,0,0,65}\ngreekCapitalLetterSigma UniversalString ::= {0,0,3,145}\n\nmy-string UniversalString ::= {\n    "This is a capital A: ", latinCapitalLetterA,\n    ", and a capital alpha: ", greekCapitalLetterAlpha,\n    "; try and spot the difference!"}\n')),(0,r.kt)("p",null,"And X.680 gives us yet another example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},'IMPORTS\n  BasicLatin, greekCapitalLetterSigma\n  FROM ASN1-CHARACTER-MODULE\n    { joint-iso-itu-t asn1(1) specification(0) modules(0) iso10646(0) };\n\n MyAlphabet ::= UniversalString (FROM (BasicLatin | greekCapitalLetterSigma))\n\n mystring MyAlphabet ::= { "abc" , greekCapitalLetterSigma , "def" }\n')),(0,r.kt)("h3",{id:"time-types"},"Time types"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"UTCTime")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"GeneralizedTime")," types are actually specified as\n",(0,r.kt)("inlineCode",{parentName:"p"},"VisibleString"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"UTCTime"),' format is "YYMMDD" for date followed by "hhmm" or "hhmmss"\nfor time, ending with either "z", "-hhmm" or "+hhmm" for time offset.'),(0,r.kt)("p",null,'Specifying "2021-12-14 04:32 CET" in ',(0,r.kt)("inlineCode",{parentName:"p"},"UTCTime")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},'"2112140332Z"\n"2112140432+0100"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"GeneralizedTime")," gives a bit more flexibility with regards to the format."),(0,r.kt)("p",null,'It consists of a calendar date of format "YYYYMMDD", followed by\neither "hh", "hhmm", "hhmmss" and optional parts ".',"[0-9]",'+", and\noptionally ending with the coordinated universal time character "z" or\nthe time offset in hours/minutes "-hhmm" or "+hhmm".'),(0,r.kt)("p",null,"These are the same, but one with higher precision and in local time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},'"2021121403.54Z" -- 3.54 hours after midnight\n"20211214043227.981935+0100" -- 3 hours, 32 minutes, 27 seconds, 981935 microseconds\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"DATE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"TIME-OF-DAY"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"DATE-TIME")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"DURATION")," was introduced after\nthe third generation of ISO 8601 was released 2004."),(0,r.kt)("p",null,"They are defined as subsets of ",(0,r.kt)("inlineCode",{parentName:"p"},"TIME"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},'DATE ::= [UNIVERSAL 31] IMPLICIT TIME\n       (SETTINGS "Basic=Date Date=YMD Year=Basic")\nTIME-OF-DAY ::= [UNIVERSAL 32] IMPLICIT TIME\n       (SETTINGS "Basic=Time Time=HMS Local-or-UTC=L")\nDATE-TIME ::= [UNIVERSAL 33] IMPLICIT TIME\n       (SETTINGS "Basic=Date-Time Date=YMD Year=Basic Time=HMS Local-or-UTC=L")\nDURATION ::= [UNIVERSAL 34] IMPLICIT TIME\n       (SETTINGS "Basic=Interval Interval-type=D")\n')),(0,r.kt)("p",null,"As I can find no real world examples from our ASN.1-files, I'm forced\nto make-up examples of these"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},'date1 DATE ::= "211214"\ntime1 TIME-OF-DAY ::= "043227"\ndate-time1 DATE-TIME ::= "211214043227"\nduration1 DURATION ::= "P0Y29M0DT0H0M0S" -- 29 months to an accuracy of 1 second\n')),(0,r.kt)("p",null,"Values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"DURATION"),' starts with "P" followed by alot of\ndifferent optional parts and formats.  If the time designation is used\nit should start with a "T" to keep months and minutes separate.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},'duration2 DURATION ::= "P2MT2M" -- 2 months and 2 minutes\nduration3 DURATION ::= "P29M0DT0.00M" -- 29 months with accuracy of one-hundredth of a minute\nduration4 DURATION ::= "P32W" -- 32 weeks\n')),(0,r.kt)("h2",{id:"structured-types"},"Structured types"),(0,r.kt)("h3",{id:"choice"},"CHOICE"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"CHOICE")," can take values from one of multiple types, ",(0,r.kt)("inlineCode",{parentName:"p"},"CHOICE"),"\ndoesn't have it's own universal tag."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"CancelArg ::= CHOICE {\n    invokeID        [0] InvokeID,\n    allRequests     [1] NULL\n}\n")),(0,r.kt)("p",null,"The value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"CancelArg")," will either of an ",(0,r.kt)("inlineCode",{parentName:"p"},"InvokeID")," type, or a\n",(0,r.kt)("inlineCode",{parentName:"p"},"NULL")," type.  It will be tagged ",(0,r.kt)("inlineCode",{parentName:"p"},"[0]")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"[1]")," respectively, that is\nwhy ",(0,r.kt)("inlineCode",{parentName:"p"},"CHOICE")," doesn't have it's own universal tag, as it is derived\nfrom ASN.1 specification."),(0,r.kt)("h3",{id:"sequence-of"},"SEQUENCE (OF)"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE OF")," are used for composing multiple types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"EventTypeSMS ::= ENUMERATED {\n    sms-CollectedInfo                   (1),\n    o-smsFailure                        (2),\n    o-smsSubmission                     (3),\n    sms-DeliveryRequested               (11),\n    t-smsFailure                        (12),\n    t-smsDelivery                       (13)\n}\nMonitorMode ::= ENUMERATED {\n    interrupted                         (0),\n    notifyAndContinue                   (1),\n    transparent                         (2)\n}\n\nSMSEvent ::= SEQUENCE {\n    eventTypeSMS   [0] EventTypeSMS,\n    monitorMode    [1] MonitorMode\n}\n\nTone ::= SEQUENCE {\n    toneID         [0] Integer4,\n    duration       [1] Integer4 OPTIONAL,\n    ...\n}\n")),(0,r.kt)("p",null,"A value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"SMSEvent")," type have information on both ",(0,r.kt)("inlineCode",{parentName:"p"},"EventTypeSMS"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"MonitorMode"),". The fixed number of fields in the ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE")," type\nare ordered.  Context-specific tagging (e.g. the ",(0,r.kt)("inlineCode",{parentName:"p"},"[0]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[1]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[2]"),"\nstuff in the examples), is frequently applied for the structured\ntypes, but one could also utilize the keywords ",(0,r.kt)("inlineCode",{parentName:"p"},"AUTOMATIC TAGGING")," in\nthe module definition."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE OF")," on the other hand, holds an arbitrary number of fields\nof a single type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"FilterItem ::= CHOICE {\n    equality         [0] AttributeValueAssertion,\n    substrings       [1] SEQUENCE {\n        type    ATTRIBUTE.&id({SupportedAttributes}),\n        strings SEQUENCE OF CHOICE {\n            initial [0] ATTRIBUTE.&Type({SupportedAttributes}{@substrings.type}),\n            any     [1] ATTRIBUTE.&Type({SupportedAttributes}{@substrings.type}),\n            final   [2] ATTRIBUTE.&Type({SupportedAttributes}{@substrings.type})\n        }\n    },\n    greaterOrEqual   [2] AttributeValueAssertion,\n    lessOrEqual      [3] AttributeValueAssertion,\n    present          [4] AttributeType,\n    approximateMatch [5] AttributeValueAssertion,\n    extensibleMatch  [6] MatchingRuleAssertion\n}\n")),(0,r.kt)("p",null,"In the quite complex example above we see that the type ",(0,r.kt)("inlineCode",{parentName:"p"},"FilterItem"),"\nis of type ",(0,r.kt)("inlineCode",{parentName:"p"},"CHOICE")," and can take subtype called ",(0,r.kt)("inlineCode",{parentName:"p"},"strings"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"strings"),"\nis of type ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE OF CHOICE")," which means it can take a list of\nzero, one or more of ",(0,r.kt)("inlineCode",{parentName:"p"},"initial"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"final"),". The example is quite\ncomplex because it also uses multiple parameterized values. see\n",(0,r.kt)("a",{parentName:"p",href:"#automatic-implicit-explicit-tags"},"Automatic, Implicit, Explicit tags")),(0,r.kt)("p",null,"We find another example in the DialoguePDUs module from\n",(0,r.kt)("a",{parentName:"p",href:"https://www.itu.int/rec/T-REC-Q.773-199706-I/en"},"Q.773")," where the\nAARQ is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE"),", and the third field ",(0,r.kt)("inlineCode",{parentName:"p"},"user-information")," is\nan ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE OF")," ",(0,r.kt)("inlineCode",{parentName:"p"},"EXTERNAL")," type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"AARQ-apdu ::= [APPLICATION 0] IMPLICIT SEQUENCE {\n  protocol-version\n    [0] IMPLICIT BIT STRING {version1(0)} DEFAULT {version1},\n  application-context-name  [1]  OBJECT IDENTIFIER,\n  user-information          [30] IMPLICIT SEQUENCE OF EXTERNAL OPTIONAL\n}\n")),(0,r.kt)("p",null,"They are quite different in how they are used, but they are encoded in\na similar way. Some languages represent ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE")," internally as a\n",(0,r.kt)("inlineCode",{parentName:"p"},"struct"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE OF")," as an array, but encoded they would look\nquite similar."),(0,r.kt)("h3",{id:"set-of"},"SET (OF)"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SET")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"SET OF")," are similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE OF"),"\nrespectively. The difference is that the composite types are\nunordered."),(0,r.kt)("p",null,"From ",(0,r.kt)("inlineCode",{parentName:"p"},"CAP-datatypes")," we find an example of a ",(0,r.kt)("inlineCode",{parentName:"p"},"SET OF")," with a\n",(0,r.kt)("a",{parentName:"p",href:"#parameterized-components"},"parameterized component")," specifying a size\nconstraint."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"GenericNumbers {PARAMETERS-BOUND : bound} ::= SET SIZE(1..bound.&numOfGenericNumbers) OF GenericNumber {bound}\n")),(0,r.kt)("p",null,"Or an example of a value from the ",(0,r.kt)("inlineCode",{parentName:"p"},"TCAP-Tools")," module in\n",(0,r.kt)("a",{parentName:"p",href:"https://www.itu.int/rec/T-REC-Q.775-199706-I/en"},"Q.775")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"cancelFailed ERROR ::= {\n  PARAMETER\n    SET {problem   [0]  CancelProblem,\n         invokeId  [1]  present < TCInvokeIdSet\n    }\n}\n")),(0,r.kt)("h3",{id:"selection"},"SELECTION"),(0,r.kt)("p",null,"The SELECTION type ",(0,r.kt)("inlineCode",{parentName:"p"},"<")," is used when one want's to obtain one of the\npossible subtypes of a ",(0,r.kt)("inlineCode",{parentName:"p"},"CHOICE")," definition."),(0,r.kt)("p",null,"If we expand the previous example from the ",(0,r.kt)("a",{parentName:"p",href:"#set-of"},"SET")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"cancel OPERATION ::= {\n  ARGUMENT  present < TCInvokeIdSet\n  ERRORS    {cancelFailed}\n}\n\ncancelFailed ERROR ::= {\n  PARAMETER\n    SET {problem   [0]  CancelProblem,\n         invokeId  [1]  present < TCInvokeIdSet\n    }\n}\n")),(0,r.kt)("p",null,"we see that the ",(0,r.kt)("inlineCode",{parentName:"p"},"ARGUMENT")," type and the invokeId field take the type\nfrom the ",(0,r.kt)("inlineCode",{parentName:"p"},"present")," field in the ",(0,r.kt)("inlineCode",{parentName:"p"},"TCInvokeIdSet")," type."),(0,r.kt)("p",null,"the definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"TCInvokeIdSet")," is as follows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"InvokeId ::= CHOICE {present  INTEGER,\n                     absent   NULL\n}\n\nTCInvokeIdSet ::= InvokeId(WITH COMPONENTS {\n                             present  (-128..127)\n                           })\n")),(0,r.kt)("p",null,"Thus ",(0,r.kt)("inlineCode",{parentName:"p"},"invokeId")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ARGUMENT")," fields will take integer values which\nare between -128 and 127."),(0,r.kt)("h1",{id:"other-concepts"},"Other concepts"),(0,r.kt)("h2",{id:"default-and-optional-keywords"},"DEFAULT and OPTIONAL keywords"),(0,r.kt)("p",null,"One can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"DEFAULT")," keyword in order to specify the default value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"CollectedDigits ::= SEQUENCE {\n  minimumNbOfDigits    [0] INTEGER (1..16) DEFAULT 1,\n  maximumNbOfDigits    [1] INTEGER (1..16),\n  endOfReplyDigit      [2] OCTET STRING (SIZE (1..2)) OPTIONAL,\n  cancelDigit          [3] OCTET STRING (SIZE (1..2)) OPTIONAL,\n  startDigit           [4] OCTET STRING (SIZE (1..2)) OPTIONAL,\n  firstDigitTimeOut    [5] INTEGER (1..127) OPTIONAL,\n  interDigitTimeOut    [6] INTEGER (1..127) OPTIONAL,\n  errorTreatment       [7] ErrorTreatment DEFAULT stdErrorAndInfo,\n  interruptableAnnInd  [8] BOOLEAN DEFAULT TRUE,\n  voiceInformation     [9] BOOLEAN DEFAULT FALSE,\n  voiceBack            [10] BOOLEAN DEFAULT FALSE\n}\n")),(0,r.kt)("p",null,"In this example we see the type ",(0,r.kt)("inlineCode",{parentName:"p"},"CollectedDigits")," where most of the\nvalues are either ",(0,r.kt)("inlineCode",{parentName:"p"},"DEFAULT")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"OPTIONAL"),". The only value that needs\nto be set is ",(0,r.kt)("inlineCode",{parentName:"p"},"maximumNbOfDigits"),"."),(0,r.kt)("h2",{id:"classes"},"Classes"),(0,r.kt)("p",null,"One can also use informal object classes in order to specify and\ndefine values for general types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"OPERATION ::= CLASS {\n  &ArgumentType          OPTIONAL,\n  &argumentTypeOptional  BOOLEAN OPTIONAL,\n  &returnResult          BOOLEAN DEFAULT TRUE,\n  &ResultType            OPTIONAL,\n  &resultTypeOptional    BOOLEAN OPTIONAL,\n  &Errors                ERROR OPTIONAL,\n  &Linked                OPERATION OPTIONAL,\n  &synchronous           BOOLEAN DEFAULT FALSE,\n  &alwaysReturns         BOOLEAN DEFAULT TRUE,\n  &InvokePriority        Priority OPTIONAL,\n  &ResultPriority        Priority OPTIONAL,\n  &operationCode         Code UNIQUE OPTIONAL\n}\nWITH SYNTAX {\n  [ARGUMENT &ArgumentType\n   [OPTIONAL &argumentTypeOptional]]\n  [RESULT &ResultType\n   [OPTIONAL &resultTypeOptional]]\n  [RETURN RESULT &returnResult]\n  [ERRORS &Errors]\n  [LINKED &Linked]\n  [SYNCHRONOUS &synchronous]\n  [ALWAYS RESPONDS &alwaysReturns]\n  [INVOKE PRIORITY &InvokePriority]\n  [RESULT-PRIORITY &ResultPriority]\n  [CODE &operationCode]\n}\n\nprovideRoutingInformation OPERATION ::= {\n  ARGUMENT  RequestArgument\n  RESULT    RoutingInformation\n  ERRORS\n    {invalidCalledNumber | subscriberNotReachable | calledBarred |\n      processingFailure}\n  LINKED    {getCallingPartyAddress}\n}\n\ngetCallingPartyAddress OPERATION ::= {\n  RESULT  CallingPartyAddress\n  ERRORS  {callingPartyAddressNotAvailable | processingFailure}\n}\n\ninvalidCalledNumber ERROR ::= {CODE  local:1}\nsubscriberNotReachable ERROR ::= {CODE  local:2}\n\nRequestArgument ::= SEQUENCE {\n  calledNumber  IsdnNumber,\n  basicService  BasicServiceIndicator OPTIONAL\n}\n\nRoutingInformation ::= CHOICE {\n  reroutingNumber    [0] IMPLICIT IsdnNumber,\n  forwardedToNumber  [1] IMPLICIT IsdnNumber\n}\n\n")),(0,r.kt)("p",null,"In the above ",(0,r.kt)("inlineCode",{parentName:"p"},"OPERATION")," class, a syntax is defined for the\nclass. This class and syntax can then be used to define specific\nvalues, for instance the ",(0,r.kt)("inlineCode",{parentName:"p"},"provideRoutingInformation")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"getCallingPartyAddress")," values."),(0,r.kt)("p",null,"We also glimse another class in the above example which I didn't\ninclude. Can you find it?"),(0,r.kt)("h2",{id:"parameterized-components"},"Parameterized components"),(0,r.kt)("p",null,"Another way to make the specs more generalized is to use parameterized\ncomponents. We've already seen a couple of examples of such, see the\nchapter for the ",(0,r.kt)("a",{parentName:"p",href:"#null"},"NULL"),", ",(0,r.kt)("a",{parentName:"p",href:"#external"},"EXTERNAL")," and ",(0,r.kt)("a",{parentName:"p",href:"#set-of"},"SET\n(OF)")," types."),(0,r.kt)("p",null,"Let's look at the example from ",(0,r.kt)("inlineCode",{parentName:"p"},"SET OF")," again."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"GenericNumbers {PARAMETERS-BOUND : bound} ::= SET SIZE(1..bound.&numOfGenericNumbers) OF GenericNumber {bound}\n\nGenericNumber {PARAMETERS-BOUND : bound} ::= OCTET STRING (SIZE(\n    bound.&minGenericNumberLength .. bound.&maxGenericNumberLength))\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"GenericNumbers")," take a parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"bound")," of the type ",(0,r.kt)("inlineCode",{parentName:"p"},"PARAMETERS-BOUND")," as input."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"PARAMETERS-BOUND")," is defined as a class with a lot of different\ninteger values, so I've minimized the class a bit."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"PARAMETERS-BOUND ::= CLASS {\n    --- a lot of other fields\n    &minGenericNumberLength  INTEGER,\n    &maxGenericNumberLength  INTEGER,\n    &numOfGenericNumbers     INTEGER,\n}\n\nWITH SYNTAX {\n    --- a lot of other fields\n    MINIMUM-FOR-GENERIC-NUMBER  &minGenericNumberLength\n    MAXIMUM-FOR-GENERIC-NUMBER  &maxGenericNumberLength\n    NUM-OF-GENERIC-NUMBERS      &numOfGenericNumbers\n}\n")),(0,r.kt)("p",null,"One could then specify different values using the ",(0,r.kt)("inlineCode",{parentName:"p"},"PARAMETERS-BOUND"),"\nclass to reuse the ",(0,r.kt)("inlineCode",{parentName:"p"},"GenericNumber")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"GenericNumbers")," types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"cAPSpecificBoundSet PARAMETERS-BOUND ::= {\n    --- again, lots of other values\n    MINIMUM-FOR-GENERIC-NUMBER                  3\n    MAXIMUM-FOR-GENERIC-NUMBER                  11\n    NUM-OF-GENERIC-NUMBERS                      5\n}\n")),(0,r.kt)("p",null,"If one would pass ",(0,r.kt)("inlineCode",{parentName:"p"},"cAPSpecificBoundSet")," to a value of type\n",(0,r.kt)("inlineCode",{parentName:"p"},"GenericNumbers"),", it would define an instance which holds 1-5\n",(0,r.kt)("inlineCode",{parentName:"p"},"GenericNumber"),"s of 3-11 octets."),(0,r.kt)("p",null,"Quite powerful if you have multiple definitions which uses similar\nstructure."),(0,r.kt)("h2",{id:"extensions"},"Extensions"),(0,r.kt)("p",null,"Sometimes you will need to support different versions of a protocol\n(or someone else need to support different version, and you just need\nto read the types of the protocol), and maybe the new version need to\nextend some types in order to include more information. Then without\nredefining everything and copy the previous version of the type to the\nnew version of the type one can use extension markers (syntax ",(0,r.kt)("inlineCode",{parentName:"p"},"..."),")."),(0,r.kt)("p",null,"Take the ",(0,r.kt)("inlineCode",{parentName:"p"},"QosMonitoringRequest")," type below as an example. In the first\nversion of the protocol (NGAP if you really want to know), the\n",(0,r.kt)("inlineCode",{parentName:"p"},"QoSMonitoringRequest")," could take only enums ",(0,r.kt)("inlineCode",{parentName:"p"},"ul"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"dl"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"both"),".\nHowever, in a subsequent version it was extended with a new enum\n",(0,r.kt)("inlineCode",{parentName:"p"},"stop"),". With the extension marker ",(0,r.kt)("inlineCode",{parentName:"p"},"...")," the v1-compilers can handle\nthe first three enums, and the v2-compilers can handle all enums from\nv1 but also the ",(0,r.kt)("inlineCode",{parentName:"p"},"stop")," enum."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"QosMonitoringRequest ::= ENUMERATED {\n    ul,\n    dl,\n    both,\n    ...\n} -- version 1\n\nQosMonitoringRequest ::= ENUMERATED {\n    ul,\n    dl,\n    both,\n    ...,\n    stop\n} -- version 2\n")),(0,r.kt)("p",null,"For enums, if there is yet a newer version, say version 3 of this type\none, you should just add the new enum under the previous enums."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"QosMonitoringRequest ::= ENUMERATED {\n    ul,\n    dl,\n    both,\n    ...,\n    stop,\n    half\n} -- imaginary version 3\n")),(0,r.kt)("p",null,"For ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SET")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"CHOICE")," one could either do the same, or to\nkeep the versions separated, add another extension mark with the new\nfields in between. One could also add version brackets to group the\nextensions and highlight the differences."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"Ax ::= SEQUENCE {\n    a INTEGER (250..253),\n    b BOOLEAN,\n    c CHOICE {\n        d INTEGER, -- version 1\n        ...,\n        [[\n            e BOOLEAN,\n            f IA5String\n        ]],\n        ... -- version 2\n    },\n    ..., -- version 1\n    [[\n        g NumericString (SIZE(3)),\n        h BOOLEAN OPTIONAL\n    ]],\n    ..., -- version 2\n    i BMPString OPTIONAL,  -- version 3\n    j PrintableString OPTIONAL -- version 3\n}\n\n")),(0,r.kt)("p",null,"Only the types ",(0,r.kt)("inlineCode",{parentName:"p"},"ENUMERATED"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SEQUENCE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SET")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"CHOICE"),", as well\nas subtype constraints, and object and value sets can be extended."),(0,r.kt)("h2",{id:"automatic-implicit-explicit-tags"},"Automatic, Implicit, Explicit tags"),(0,r.kt)("p",null,"When an value is transmitted all ambiguities need to be removed. That\nis why every type needs to have an unique identifier, called a tag."),(0,r.kt)("p",null,"The section ",(0,r.kt)("a",{parentName:"p",href:"#default-and-optional-keywords"},"DEFAULT and OPTIONAL\nkeywords")," has a good example I will\nexplain."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"CollectedDigits ::= SEQUENCE {\n  minimumNbOfDigits    [0] INTEGER (1..16) DEFAULT 1,\n  maximumNbOfDigits    [1] INTEGER (1..16),\n  endOfReplyDigit      [2] OCTET STRING (SIZE (1..2)) OPTIONAL,\n  cancelDigit          [3] OCTET STRING (SIZE (1..2)) OPTIONAL,\n  startDigit           [4] OCTET STRING (SIZE (1..2)) OPTIONAL,\n  firstDigitTimeOut    [5] INTEGER (1..127) OPTIONAL,\n  interDigitTimeOut    [6] INTEGER (1..127) OPTIONAL,\n  errorTreatment       [7] ErrorTreatment DEFAULT stdErrorAndInfo,\n  interruptableAnnInd  [8] BOOLEAN DEFAULT TRUE,\n  voiceInformation     [9] BOOLEAN DEFAULT FALSE,\n  voiceBack            [10] BOOLEAN DEFAULT FALSE\n}\n")),(0,r.kt)("p",null,"In this sequence we can see that many of the values are optional and\nsome have defaults, only the value ",(0,r.kt)("inlineCode",{parentName:"p"},"maximumNbOfDigits")," is mandatory."),(0,r.kt)("p",null,"When the sending side transmits a value of ",(0,r.kt)("inlineCode",{parentName:"p"},"CollectedDigits")," type, the\nreceiving side will get a sequence of the values mentioned. With\nBER-encoding each defined value will have an identifier, a length (of\nthe value transmitted) and the value. This is called a\nTag-Length-Value or TLV for short."),(0,r.kt)("p",null,"All basic types already has an universal tag as stated in the ",(0,r.kt)("a",{parentName:"p",href:"#types"},"types\ntable"),", but the composite types does not. (If not tagged, how\nwould it see the difference between ",(0,r.kt)("inlineCode",{parentName:"p"},"endOfReplyDigit"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"cancelDigit"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"startDigit")," in the example above?)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},'RoutingInformation ::= CHOICE {\n  reroutingNumber    [0] IMPLICIT IsdnNumber,\n  forwardedToNumber  [1] IMPLICIT IsdnNumber\n}\n\nIsdnNumber ::= SEQUENCE {\n  typeOfAddress  TypeOfAddress,\n  digits         TelephonyString\n}\n\nTypeOfAddress ::= ENUMERATED {national(0), international(1), private(2)}\n\nTelephonyString ::=\n  IA5String\n    (FROM ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "*" |\n           "#"))(SIZE (1..15))\n\n')),(0,r.kt)("p",null,"A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"RoutingInformation")," in this example will with BER encoding\nonly transmit the tag ",(0,r.kt)("inlineCode",{parentName:"p"},"[0]")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"[1]")," (and of course the length and\nvalue). It counts on that the receiving part has the same version of\nthe ASN.1 and knows the abstract syntax. If it wouldn't have been\n",(0,r.kt)("inlineCode",{parentName:"p"},"IMPLICIT"),", then it would have sent either tags ",(0,r.kt)("inlineCode",{parentName:"p"},"[0]")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"[1]"),"\nfollowed by the tags for ",(0,r.kt)("inlineCode",{parentName:"p"},"TypeOfAddress")," (ENUMERATED) ",(0,r.kt)("inlineCode",{parentName:"p"},"[10]"),", and tags\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"TelephonyString")," (IA5String) ",(0,r.kt)("inlineCode",{parentName:"p"},"[4]"),"."),(0,r.kt)("p",null,"One can specify ",(0,r.kt)("inlineCode",{parentName:"p"},"IMPLICIT")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"EXPLICIT")," tagging on module basis,\nwhere the ",(0,r.kt)("inlineCode",{parentName:"p"},"DEFINITIONS")," are assigned."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"DEFINITIONS IMPLICIT TAGS ::= BEGIN\n")),(0,r.kt)("p",null,"Instead of writing all the tags self (explicitly in both cases), one\ncan instead use the keywords ",(0,r.kt)("inlineCode",{parentName:"p"},"AUTOMATED TAGS"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"DEFINITIONS AUTOMATIC TAGS ::= BEGIN\n")),(0,r.kt)("p",null,"This will add tags to the composit types that doesn't have them\n(explicitly) set."),(0,r.kt)("h2",{id:"deprecations-and-discouragements"},"Deprecations and discouragements"),(0,r.kt)("p",null,"Some things have been deprecated from earlier ASN.1 specifications,\nand use of these are strongly discouraged."),(0,r.kt)("h3",{id:"any"},"ANY"),(0,r.kt)("p",null,"First out is the ",(0,r.kt)("inlineCode",{parentName:"p"},"ANY")," type, which could take the form of any\nvalue. It's like an unrestricted ",(0,r.kt)("inlineCode",{parentName:"p"},"CHOICE")," type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"Invoke ::= SEQUENCE {\n    invokeID           InvokeIdType,\n    linkedID       [0] InvokeIdType OPTIONAL,\n    operationCode      MAP-OPERATION,\n    parameter          InvokeParameter OPTIONAL\n}\nInvokeParameter ::= ANY\n")),(0,r.kt)("p",null,"Problem with this is that the ASN.1 compiler does not have a formal\nway of knowing which values are approved. The use of ",(0,r.kt)("inlineCode",{parentName:"p"},"ANY")," also\nusually meant it was coupled with some other value, for instance the\n",(0,r.kt)("inlineCode",{parentName:"p"},"operationCode")," in the example above."),(0,r.kt)("p",null,"To make this link one could have used ",(0,r.kt)("inlineCode",{parentName:"p"},"DEFINED BY")," specifying which\nfield the ",(0,r.kt)("inlineCode",{parentName:"p"},"ANY")," type is coupled with. The drawback with this solution\nis that it still has an ambiguous meaning, and the types are of no use\nfor the application designer."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},"ExtensionField ::= SEQUENCE {\n    type        INTEGER,\n    --  shall identify the value of an EXTENSION type\n    criticality ENUMERATED {\n        ignore(0),\n        abort(1)\n    } DEFAULT ignore,\n    value   [1] ANY DEFINED BY type\n}\n")),(0,r.kt)("p",null,"Instead the concept of informal object classes and parameterized\ncomponents were introduced."),(0,r.kt)("h3",{id:"macros"},"Macros"),(0,r.kt)("p",null,"Macros were removed because they were poorly documented and too\ngeneral. Because of this they were hard to implement and automate in\nthe compilers. They follow the BNF notation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asn.1"},'OPERATION MACRO ::=\nBEGIN\n    TYPE NOTATION ::= Parameter Result Errors LinkedOperations\n    VALUE NOTATION ::= value (VALUE CHOICE { localValue INTEGER, globalValue OBJECT IDENTIFIER } )\n    Parameter ::= ArgKeyword NamedType | empty\n    ArgKeyword ::= "ARGUMENT" | "PARAMETER"\n    Result ::= "RESULT" ResultType | empty\n    Errors ::= "ERRORS" "{"ErrorNames"}" | empty\n    LinkedOperations ::= "LINKED" "{"LinkedOperationNames"}" | empty\n    ResultType ::= NamedType | empty\n    ErrorNames ::= ErrorList | empty\n    ErrorList ::= Error | ErrorList "," Error\n    Error ::= value (ERROR)\n             -- shall reference an error value\n             | type\n             -- shall reference an error type\n             -- if no error value is specified\n    LinkedOperationNames ::= OperationList | empty\n    OperationList ::= Operation | OperationList "," Operation\n    Operation ::= value (OPERATION)\n                  -- shall reference an operation value\n                  | type\n                  -- shall reference an operation type if\n                  -- no operation value is specified\n    NamedType ::= identifier type | type\nEND\n')),(0,r.kt)("p",null,"The two needed fields of the macro are ",(0,r.kt)("inlineCode",{parentName:"p"},"TYPE NOTATION")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"VALUE\nNOTATION"),". The rest of the fields are the value sequence defining what\nthe macro should insert. Quotes define the string to insert (excluding\nthe actual quotes), ",(0,r.kt)("inlineCode",{parentName:"p"},"empty")," inserts nothing. ",(0,r.kt)("inlineCode",{parentName:"p"},"identifier"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),", or\n",(0,r.kt)("inlineCode",{parentName:"p"},"type")," are used to infer different things. Dubuisson has (yet again) a\ngood chapter on this topic."),(0,r.kt)("p",null,"Also here one should use informal object classes and parameterized\ncomponents instead of using macros."),(0,r.kt)("h1",{id:"encodings"},"Encodings"),(0,r.kt)("p",null,"There are numerous codecs when transmitting the abstract syntax, all\nwith different pros and cons."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Short name"),(0,r.kt)("th",{parentName:"tr",align:null},"Long name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BER"),(0,r.kt)("td",{parentName:"tr",align:null},"Basic encoding rules")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DER"),(0,r.kt)("td",{parentName:"tr",align:null},"Distinguished encoding rules")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CER"),(0,r.kt)("td",{parentName:"tr",align:null},"Canonical encoding rules")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PER"),(0,r.kt)("td",{parentName:"tr",align:null},"Packed encoding rules")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"OER"),(0,r.kt)("td",{parentName:"tr",align:null},"Octet encoding rules")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"XER"),(0,r.kt)("td",{parentName:"tr",align:null},"XML encoding rules")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"EXER"),(0,r.kt)("td",{parentName:"tr",align:null},"Extended XML encoding rules")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"JER"),(0,r.kt)("td",{parentName:"tr",align:null},"JSON encoding rules")))),(0,r.kt)("p",null,"BER is the oldest encoding rule for ASN.1. It uses Tag-Length-Value\nformat where all tags, lengths and values are multiples of\noctets. Because this was the first encoding rule it was named ",(0,r.kt)("inlineCode",{parentName:"p"},"basic"),"\nto indicate that there might be more standardized encoding rules in\nthe future."),(0,r.kt)("p",null,"DER and CER are subsets of BER, which was added for developers of\nX.400 email and X.500 directory applications. It provides means to\nmake sure bit strings are not altered during transfer. The main\ndifference between DER and CER is that DER uses a definite-length\nformat and CER an indefinite-length format, so CER is best used for\napplications that transfer a big amount of data."),(0,r.kt)("p",null,"PER is the most compact format, and used for bandwith conservation. It\ndoes not send the Tag of the TLV because the order in which components\nof the message occur is known.  PER also does not send the Length of\nthe TLV if the Value has a fixed length. It uses information from\nASN.1 message description to eliminate redundant information from the\nValue portion. It can either be aligned to multiple of octets by\npadding each value with '0's, or unaligned (U-PER/Unaligned PER) which\nis more compact but take more time to decode."),(0,r.kt)("p",null,"OER was adapted from PER and uses an octet oriented format, so the\nlength of all specified Tags, Lengths, and Values are padded to be\nmultiples of 8 bits octets as in BER. OER is usually faster than both\nBER and PER with regards to encoding and decoding."),(0,r.kt)("p",null,'XER, CXER and EXER are used for transmitting XML format. CXER is used\nfor transmitting data canonically, e.g. used by security applications.\nEXER or Extended XER is used when "stylish" features is wanted, and\nadds possibility to extend the encoder for instance when wanting to\ninsert processing instructions or comments into the XML.'),(0,r.kt)("p",null,"JER is used when transmitting JSON in accordance to the format\nspecified in\n",(0,r.kt)("a",{parentName:"p",href:"https://www.ecma-international.org/publications-and-standards/standards/ecma-404/"},"ECMA-404"),"."),(0,r.kt)("p",null,"There are probably a bunch of others as well, but these are the ones\nthat have a specification."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"ITU-T number"),(0,r.kt)("th",{parentName:"tr",align:null},"Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.690"},"X.690")),(0,r.kt)("td",{parentName:"tr",align:null},"ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.691"},"X.691")),(0,r.kt)("td",{parentName:"tr",align:null},"ASN.1 encoding rules: Specification of Packed Encoding Rules (PER)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.692"},"X.692")),(0,r.kt)("td",{parentName:"tr",align:null},"ASN.1 encoding rules: Specification of Encoding Control Notation (ECN)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.693"},"X.693")),(0,r.kt)("td",{parentName:"tr",align:null},"ASN.1 encoding rules: XML Encoding Rules (XER)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.694"},"X.694")),(0,r.kt)("td",{parentName:"tr",align:null},"ASN.1 encoding rules: Mapping W3C XML schema definitions into ASN.1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.695"},"X.695")),(0,r.kt)("td",{parentName:"tr",align:null},"ASN.1 encoding rules: Registration and application of PER encoding instructions")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.696"},"X.696")),(0,r.kt)("td",{parentName:"tr",align:null},"ASN.1 encoding rules: Specification of Octet Encoding Rules (OER)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://www.itu.int/rec/T-REC-X/recommendation.asp?lang=en&parent=T-REC-X.697"},"X.697")),(0,r.kt)("td",{parentName:"tr",align:null},"ASN.1 encoding rules: Specification of JavaScript Object Notation Encoding Rules (JER)")))),(0,r.kt)("h1",{id:"final-words"},"Final words"),(0,r.kt)("p",null,"Congratulations for making through this blog post. You deserve a\nmedal, and I hope this can help you understand the complexity and\ngreatness of ASN.1."),(0,r.kt)("p",null,"We have gone through the ",(0,r.kt)("strong",{parentName:"p"},"basics")," of ASN.1, there are still a lot of\nthings to be uncovered. You now understand the most common basic and\nstructured types, as well as the main differences between the\ndifferent encodings."),(0,r.kt)("p",null,"If I write a part 2 I will take you through the Diameter specs\ninstead, which are much more straighforward."),(0,r.kt)("p",null,"Image from ",(0,r.kt)("a",{parentName:"p",href:"https://xkcd.com"},"xkcd")," describing how I feel with ASN.1:"),(0,r.kt)("a",{class:"image",href:"https://xkcd.com/208/"},(0,r.kt)("img",{src:"https://imgs.xkcd.com/comics/regular_expressions.png"})))}c.isMDXComponent=!0}}]);